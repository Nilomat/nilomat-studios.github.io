 **complete tutorial/course** for writing programs in **NI-Script** — your simple high-level language for the NI\_CPU.

---

# NI-Script Tutorial: Complete Course

---

## Introduction

NI-Script is a simple language designed to make programming the NI\_CPU easier. Instead of writing low-level instructions directly, you write readable commands that get compiled into assembly and machine code.

---

## Table of Contents

1. [Getting Started](#getting-started)
2. [Basic Commands](#basic-commands)
3. [Working with Data](#working-with-data)
4. [Arithmetic Operations](#arithmetic-operations)
5. [Output and I/O](#output-and-io)
6. [Control Flow and Jumps](#control-flow-and-jumps)
7. [Full Example Program](#full-example-program)
8. [Tips & Best Practices](#tips--best-practices)

---

## 1. Getting Started

NI-Script commands are **one per line**. Commands are case-insensitive but recommended to be lowercase for consistency.

Example:

```plaintext
load 5
set ar1
load 10
set ar2
add
output
```

---

## 2. Basic Commands

### `load <value>`

* Loads an 8-bit value (0–255) into the temporary register (`zp`).
* The value is stored in **external data** memory (one byte per instruction).
* Example:

```plaintext
load 42
```

### `set ar1` / `set ar2`

* Move the value from `zp` into register `ar1` or `ar2`.
* Used to prepare operands for arithmetic.
* Example:

```plaintext
load 10
set ar1
load 5
set ar2
```

### `noop`

* Does nothing.
* Useful for timing or placeholders.
* Example:

```plaintext
noop
```

---

## 3. Working with Data

* Every command corresponds to one external data byte (even if unused).
* For commands like `load`, the external data byte is the value to load.
* For others, external data byte is `00`.

---

## 4. Arithmetic Operations

You operate on `ar1` and `ar2`, and the result is stored back in `zp`.

### Available arithmetic commands:

| Command      | Description                           |
| ------------ | ------------------------------------- |
| `add`        | Add `ar1` + `ar2`                     |
| `sub`        | Subtract `ar1` - `ar2`                |
| `and`        | Bitwise AND                           |
| `or`         | Bitwise OR                            |
| `xor`        | Bitwise XOR                           |
| `ar2_gt_ar1` | Compare if `ar2` > `ar1` (sets flags) |
| `ar1_gt_ar2` | Compare if `ar1` > `ar2` (sets flags) |

Example:

```plaintext
load 7
set ar1
load 3
set ar2
sub
output
```

This calculates `7 - 3` and outputs `4`.

---

## 5. Output and I/O

### Output commands:

| Command   | Description                         |
| --------- | ----------------------------------- |
| `output`  | Send `zp` value to output port      |
| `output2` | Send `zp` value to secondary output |

Example:

```plaintext
load 255
output
```

---

## 6. Control Flow and Jumps

You can jump to a program address to change the instruction flow.

### Jump Command:

```plaintext
jump <address>
```

* Jumps to the specified program memory address (0–255).
* Internally compiled as two instructions:

  * `von data nach zp` (load address)
  * `von zp nach count` (set program counter)

Example:

```plaintext
jump 16
```

---

## 7. Full Example Program

Calculate `(5 + 3) - 2` and output the result.

```plaintext
load 5
set ar1
load 3
set ar2
add        # ar1 + ar2 = 8 in zp
set ar1    # move result to ar1
load 2
set ar2
sub        # ar1 - ar2 = 6 in zp
output     # output result
noop       # end placeholder
```

---

## 8. Tips & Best Practices

* Always use `load` before `set ar1` or `set ar2` to prepare operands.
* Keep track of where your data values are (they are separate from code).
* Use `noop` to pad or delay instructions if needed.
* Use `jump` for loops or conditional branching (needs manual flag handling).
* Comments are not supported in the compiler, but you can add comments for yourself in your code editor.

---

## Summary Table of Commands

| Command       | Description             | External Data Needed?                    |
| ------------- | ----------------------- | ---------------------------------------- |
| `load <val>`  | Load constant into zp   | Yes (value)                              |
| `set ar1`     | Move zp to ar1          | No (0x00 placeholder)                    |
| `set ar2`     | Move zp to ar2          | No                                       |
| `add`         | Add ar1 + ar2 → zp      | No                                       |
| `sub`         | Subtract ar1 - ar2 → zp | No                                       |
| `and`         | Bitwise AND             | No                                       |
| `or`          | Bitwise OR              | No                                       |
| `xor`         | Bitwise XOR             | No                                       |
| `ar2_gt_ar1`  | Compare ar2 > ar1       | No                                       |
| `ar1_gt_ar2`  | Compare ar1 > ar2       | No                                       |
| `output`      | Output zp               | No                                       |
| `output2`     | Output2 zp              | No                                       |
| `jump <addr>` | Jump to address         | Yes (address), plus one `00` placeholder |

---


## Summary Table of Commands

| Command       | Description             | External Data Needed?                    |
| ------------- | ----------------------- | ---------------------------------------- |
| `load <val>`  | Load constant into zp   | Yes (value)                              |
| `set ar1`     | Move zp to ar1          | No (0x00 placeholder)                    |
| `set ar2`     | Move zp to ar2          | No                                       |
| `set ra`      | set the ram adress to zp| No                                       |
| `set ram`     | set current ram to zp   | No                                       |
| `set zpe`     | set zpe to zp           | No                                       |
| `get ram`     | set zp to current ram   | No                                       |
| `get zpe`     | set zp to zpe           | No                                       |
| `get input`   | set zp to user input    | No                                       |
| `get count`   | get the current adress  | No                                       |
| `get sr`      | get the mem sector reg  | No                                       |
| `set sr`      | set the mem sector reg  | No                                       |
| `add`         | Add ar1 + ar2 → zp      | No                                       |
| `sub`         | Subtract ar1 - ar2 → zp | No                                       |
| `and`         | Bitwise AND             | No                                       |
| `comp`        | jump to zpif ar1==ar2   | No                                       |
| `or`          | Bitwise OR              | No                                       |
| `xor`         | Bitwise XOR             | No                                       |
| `ar2_gt_ar1`  | Compare ar2 > ar1       | No                                       |
| `ar1_gt_ar2`  | Compare ar1 > ar2       | No                                       |
| `output`      | Output zp               | No                                       |
| `output2`     | Output2 zp              | No                                       |
| `jump <addr>` | Jump to address         | Yes (address), plus one `00` placeholder |
| `jumpzp`      |jump to value stored in zp| No                                      |

